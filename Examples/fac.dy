-- Self-recursive binding
let fac = \n.
  match n
  | 0 -> 1
  | n: Num -> n * fac (n - 1)

-- With fixed points
and fac' = \f n.
  match n
  | 0 -> 1
  | n: Num -> n * f (n - 1)

-- Haskell-style `fix`
and fix = \f. let x = f x in x
and facF = fix fac'

-- Y combinator
and y = \f. (\x. f (x x)) (\x. f (x x))
and facY = y fac'
in

print (fac 100) *>
print (facF 100) *>
print (facY 100)

module BF

import Core.Bool
import Core.Function
import Core.IO
import Core.IO.Node
import Core.List
import Core.Math
import Core.Seq
import Core.String

parse =
  let go scope stack = \case
    | [] ->
      ( case stack of
        | [] -> reverse scope
        | _ -> throw "Ummatched \"[\"."
      )
    | "+" :: cs -> go (Incr :: scope) stack cs
    | "-" :: cs -> go (Decr :: scope) stack cs
    | "<" :: cs -> go (MovL :: scope) stack cs
    | ">" :: cs -> go (MovR :: scope) stack cs
    | "," :: cs -> go (Read :: scope) stack cs
    | "." :: cs -> go (Write :: scope) stack cs
    | "[" :: cs -> go [] (scope :: stack) cs
    | "]" :: cs ->
      ( case stack of
        | [] -> throw "Unmatched \"]\"."
        | parent :: stack -> go (Loop (reverse scope) :: parent) stack cs
      )
    | _ :: cs -> go scope stack cs
  in
  go [] []
and

zeros = 0 :: zeros and
tape = { left = zeros, crr = 0, right = zeros } and

wrap = \case
  | 256 -> 0
  | -1 -> 255
  | n -> n
and

evalOp op tape@{ left, crr, right } =
  case op of
  | Incr -> (\c -> pure { left, crr = c, right }) $! wrap (crr + 1)
  | Decr -> (\c -> pure { left, crr = c, right }) $! wrap (crr - 1)
  | MovL -> (case left of h :: t -> pure { left = t, crr = h, right = crr :: right })
  | MovR -> (case right of h :: t -> pure { left = crr :: left, crr = h, right = t })
  | Read -> getChar >>= \c -> (\c -> pure { left, crr = c, right }) $! toCharCode c
  | Write -> putChar (fromCharCode crr) *> pure tape
  | Loop ops ->
      case crr of
      | 0 -> pure tape
      | _ -> evalOps ops tape >>= evalOp (Loop ops)
and

evalOps ops tape =
  case ops of
  | [] -> pure tape
  | op :: ops -> evalOp op tape >>= evalOps ops
and

eval ops = evalOps ops tape *> pure () and

main =
  getArgs >>= \case
    | [file] -> readFile file >>= chars; parse; eval
    | _ -> throw "Expecting exactly 1 arg."

module BF

import Core.Function
import Core.IO
import Core.IO.NodeAPI
import Core.Math
import Core.Seq
import Core.String

incr k c = k $! (c + 1) .&. 255 and
decr k c = k $! (c - 1) .&. 255 and
movL k c (h :: t) r = k h t (c :: r) and
movR k c l (h :: t) = k h (c :: l) t and
read k _ l r = getChar >>= \c -> (k $! toCharCode c) l r and
write k c l r = putChar (fromCharCode c) *> k c l r and
loop op k =
  let go = \case
    | 0 -> k 0
    | c -> op go c
  in go
and

parse s =
  let len = length s
  and go l o i =
    case i == len of
    | True -> ( case l of | True -> throw "Unmatched [" | _ -> {o,i} )
    | _ ->
        case s ! i of
        | "+" -> go l (o . incr) (i + 1)
        | "-" -> go l (o . decr) (i + 1)
        | "<" -> go l (o . movL) (i + 1)
        | ">" -> go l (o . movR) (i + 1)
        | "," -> go l (o . read) (i + 1)
        | "." -> go l (o . write) (i + 1)
        | "[" -> ( case go True id (i + 1) of | {o = o', i} -> go l (o . loop o') i )
        | "]" -> ( case l of | True -> {o, i = i + 1} | _ -> throw "Unmatched ]" )
        | _ -> go l o (i + 1)
  in (go False id 0).o
and

zeros = 0 :: zeros and

main =
  do   [file] <- getArgs
  then code <- readFile file
  then parse code (\_ _ _ -> pure ()) 0 zeros zeros

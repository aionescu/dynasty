module BF

import Core.Function
import Core.IO
import Core.IO.NodeAPI
import Core.Math
import Core.Seq
import Core.String

incr k c = k $! (c + 1) .&. 255 and
decr k c = k $! (c - 1) .&. 255 and
movL k c (h :: t) r = k h t (c :: r) and
movR k c l (h :: t) = k h (c :: l) t and
read k _ l r = getChar >>= \c -> (k $! toCharCode c) l r and
write k c l r = putChar (fromCharCode c) *> k c l r and
loop op k =
  let go = \case
    | 0 -> k 0
    | c -> op go c
  in go
and

parse str =
  let go state@{ op, stack } = \case
    | "+" -> { op = op . incr, stack }
    | "-" -> { op = op . decr, stack }
    | "<" -> { op = op . movL, stack }
    | ">" -> { op = op . movR, stack }
    | "," -> { op = op . read, stack }
    | "." -> { op = op . write, stack }
    | "[" -> { op = id, stack = op :: stack }
    | "]" ->
      ( case stack of
        | [] -> throw "Unmatched \"]\"."
        | parent :: stack -> {op = parent . loop op, stack }
      )
    | _ -> state
  in
    case unsafeFoldChars go { op = id, stack = [] } str of
    | { op, stack = [] } -> op
    | _ -> throw "Ummatched \"[\"."
and

zeros = 0 :: zeros and

main =
  do   [file] <- getArgs
  then code <- readFile file
  then parse code (\_ _ _ -> pure ()) 0 zeros zeros
